section0

카프카는 source application 과 target application을 커플링을 약하게 만들기 위해서 발명되었다
source application --> kafka --> target application 으로 이루어져 있다.
ex)
source application에서는 클릭로그, 결제로그 같은 것을 형태 제한없이 카프카로 보내면, 카프카는 target application으로 보내 로그 적재 및 로그 처리를 한다.

카프카는 토픽에 데이터를 저장하는데 토픽은 큐와 비슷하다.
큐에 데이터를 넣는 역할은 producer, 데이터를 가져가는 역할은 consumer가 한다.
producer는 source application ,consumer은 target application라고 할 수 있다.

-------------------------------------------------------------------------------------------
토픽
데이터가 들어가는 곳을 토픽이라고 한다.
토픽은 이름을 가질 수 있다.
하나의 토픽은 여러개의 파티션을 가질 수 있으며, 파티션은 0번부터 시작된다.
프로듀서가 데이터를 넣으면 컨슈머가 데이터를 가져가고, 제일 마지막 데이터까지 가져간 다음에는 다른 데이터가 들어올 때까지 대기한다.
컨슈머가 데이터를 가져간 다음 데이터를 삭제하지 않는데 다른 컨슈머가 붙을 경우 해당 데이터를 사용할 수 있다.
다만 이렇게 가져가려면 컨슈머 그룹이 달라야하고, auto.offset.reset = earliest로 되어 있어야 한다

파티션이 여러개 있을 경우 데이터를 넣을 때 키를 정해주면 키에 해당하는 파티션으로 들어가고, 키를 정해주지 않으면 라운드 로빈방식으로 들어간다.

파티션은 늘리는 것을 가능하지만, 줄이는 것은 불가능하다.
파티션의 데이터는 옵션에 따라 삭제되는 시간이 다르다.
log.retention.ms : 최대 record 보존시간
log.retention.byte :최대 record 보존크기(byte)

-------------------------------------------------------------------------------------------
브로커, 복제, isr(in-sync-replication)
복제는 카프카 애플리케이션의 핵심
브로커 : 카프카가 설치되어 있는 서버단위
보통 3개 이상의 브로커를 사용하는 것을 권장한다.

레플리케이션은 파티션의 복사를 뜻한다.
partition:1, replication:1 일 경우 파티션이 하나만 존재하는 것이고,
partition:1, replication:2일 경우 다른 브로커에 해당 파티션이 복제되어 존재한다.
브로커 개수에 따라 복제본이 제한된다.
원본을 리더 파티션, 복제본을 팔로우 파티션이라고 한다.
모든 파티션을 가리켜서 in-sync replication이라고 한다.
프로듀서가 토픽을 리더파티션에게 전달한다.
ack = 0,1,all
0: 
프로듀서가 리더파티션에게 데이터를 보내는데 결과값을 받지 못한다.
속도는 빠르지만 데이터의 유실 가능성이 있다.
1:
데이터를 정상적으로 받았는지 응답값을 받는데, 복제 되었는지는 확인할 수 없다.
all:
데이터를 잘 받았는지, 복제는 되었는지 확인할 수 있다.
데이터 유실은 없지만 속도가 현저히 느려진다.


-------------------------------------------------------------------------------------------
파티셔너

프로듀서가 데이터를 보낼 때는 파티셔너를 통해서 파티션으로 전달한다.
파티션의 키가 있을 경우, 해당 데이터는 키를 가지고 있는 파티션에 들어간다.
키가 없는 경우 라운드로빈으로 들어간다 즉 파티션에 적절히 분배되어 들어간다.
파티셔너는 커스텀할 수 있다.
vip고객을 위해 더 빠르게 데이터를 처리할 수 있게 개발할 수도 있다 --> 우선순위 큐와 비슷하다.

-------------------------------------------------------------------------------------------
카프카 lag
모니터링 지표
컨슈머가 데이터를 어디까지 가져갔는지 확인하기 위해서 사용
lag은 각 파티션의 오프셋 기준으로 프로듀서가 넣은 데이터의 오프셋과 컨슈머가 가져간 데이터의 오프셋의 차이를 기준으로 만든다.
파티션의 개수에 따라 lag가 여러개 존재할 수 있다

*
오프셋 : 파티션에 데이터가 들어갈 때 데이터는 오프셋이라는 번호를 받는다

-------------------------------------------------------------------------------------------
카프카 랙을 모니터링하기위해 오픈소스 burrow를 이용함
컨슈머 단계에서 lag을 수집하는 것이 위험하고, 컨슈머가 추가될 때마다 새로 만들어야 한다.
burrow는 golang으로 구성되어 있다.
http api를 통해 모니터링이 가능하다.

-------------------------------------------------------------------------------------------
메시징 플랫폼
메시지 브로커는 이벤트 브로커 역할을 못한다.
메시지 브로커는 메시지 기반 미들웨어로 사용
메세지를 처리하고 나면 즉시 혹은 빨리 삭제된다.
이벤트 브로커는 메시지 브로커 역할을 할 수 있다
이벤트를 인덱스로 관리, 보존할 수 있다.
이벤트를 저장함으로써 장애가 일어난 지점으로부터 재처리할 수 있다.
많은 데이터를 실시간으로 처리할 수 있다.
